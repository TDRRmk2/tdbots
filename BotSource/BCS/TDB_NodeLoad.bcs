struct ParseCtx
{
	int pos;
	str s;
	bool done;
};

int ParseGetInt (struct ParseCtx module *parse)
{
	char c;
	int ret;
	bool negate;

	if(parse.s[parse.pos] == '-')
	{
		negate = true;
		parse.pos++;
	}

	if(parse.done)
	{
		TDB_Log(TDB_LOG_ERROR, StrParam(s:"unexpected end of node list."));
		bcs::exit();
	}

	while(true)
	{
		c = parse.s[parse.pos++];

		if(c == ';')
		{
			break;
		}
		else if(c == '\0')
		{
			parse.done = true;
			break;
		}

		if( (c >= '0') && (c <= '9') )
		{
			ret = (ret * 10) + (c - '0');
		}
		else
		{
			TDB_Log(TDB_LOG_ERROR, StrParam(s:"unexpected character ", c:c, s:" while parsing node list."));
			bcs::exit();
		}
	}

	if(negate)
		ret = -ret;

	return ret;
}

void ParseNodeCommon (struct ParseCtx module *parse, struct TDB_Node module *n)
{
	n.x = ParseGetInt(parse);
	n.y = ParseGetInt(parse);
	n.z = ParseGetInt(parse);
}

void ParseJumpNode (struct ParseCtx module *parse, struct TDB_Node module *n)
{
	ParseNodeCommon(parse, n);
	n.angle = ParseGetInt(parse) * 256;
	n.arg1 = ParseGetInt(parse);
	n.arg2 = ParseGetInt(parse);
}

void function(struct ParseCtx module*, struct TDB_Node module*)& ParseFuncs =
{
	ParseNodeCommon,
	ParseJumpNode,
	ParseNodeCommon,
	ParseNodeCommon,
	ParseNodeCommon
};

Script "TDB_ProcessNodelist" (str string)
{
	static ParseCtx parse;
	static TDB_NodeT n;

	int stringLen = strlen(string);

	//Don't bother doing anything if it's just empty
	if(!stringLen)
		return;

	//StrMid parameters, to copy a full actor name to the StartWeapons array
	int strmidstart;
	int strmidend;

	//Keeps track of current character index so it can be passed to strmidstart
	//even after restarting it
	int strmidstart2;

	//Actor name
	int currentarrayindex;

	int currProperty;

	for(int currchar = 0; currchar <= stringlength; currchar++)
	{
		if(currchar == stringlength)
		{
			amountofnodes = currentarrayindex;
			NodePropStr[currentarrayindex][curraxis] = strmid(string, strmidstart, strmidend);
			if(version == 0)
			{
				NodePropStr[currentarrayindex][NODE_TYPE] = "";
				currentarrayindex++;
			}
			return;
		}
		if(GetChar(string, currchar) == ';')
		{
			//log(s:strmid(string, strmidstart, strmidend));
			NodePropStr[currentarrayindex][curraxis] = strmid(string, strmidstart, strmidend);
			curraxis++;
			if( (version == 0) && (curraxis > AXIS_Z) )
			{
				NodePropStr[currentarrayindex][NODE_TYPE] = "";
				currentarrayindex++;
			}
			else if( (version == 1) && (curraxis > NODE_TYPE) )
			{
				currentarrayindex++;
			}

			strmidstart = strmidstart2+1; //needs to be AFTER the separator
			strmidstart2++;
			strmidend = 0;
			//log(s: "strmidstart = ",i:strmidstart);
		}
		else
		{
			strmidend++;
			strmidstart2++;
			//log(s: "strmidend = ",i:strmidend);
		}
	}
}

//And oh boy does this code look messy!
int nodelistVersion;
function str GetNodelist (bool silent)
{
	str mapLmp = StrParam(n:PRINTNAME_LEVEL);
	str cvarToCheck = StrParam(s:MapLmp, s:"NodesNew");
	str strToProcess = StrParam(l:cvartocheck);

	if(StrToProcess == cvartocheck)
	{
		cvarToCheck = StrParam(s:mapLmp, s:"Nodes");
		strToProcess = StrParam(l:cvartocheck);

		if(strToProcess == cvarToCheck)
		{
			return "";
		}
		else
		{
			nodelistVersion = 0;
			if(!silent)
				Log(s:"Nodes found, loading...");
		}
	}
	else
	{
		nodelistVersion = 1;
		if(!silent)
			Log(s:"Nodes found, loading...");
	}

	return strToProcess;
}

Script "TDBots_LoadNodes" OPEN
{
	ProcessNodelist(GetNodelist(FALSE), NodelistVersion);

	delay(1);

	int TID;
	while(CurrArrayIndex <= amountofnodes)
	{
		if((int)NodePropStr[CurrArrayIndex][AXIS_X] != 0)
		{
			TID = UniqueTID();

			switch(StrToInt(NodePropStr[CurrArrayIndex][NODE_TYPE]))
			{
				case NODE_NORMAL:
				SpawnForced("TDBots_PathNode",
				fixed(StrToInt(NodePropStr[CurrArrayIndex][AXIS_X])),
				fixed(StrToInt(NodePropStr[CurrArrayIndex][AXIS_Y])),
				fixed(StrToInt(NodePropStr[CurrArrayIndex][AXIS_Z])), TID);
				break;

				case NODE_JUMP:
				SpawnForced("TDBots_JumpNode",
				fixed(StrToInt(NodePropStr[CurrArrayIndex][AXIS_X])),
				fixed(StrToInt(NodePropStr[CurrArrayIndex][AXIS_Y])),
				fixed(StrToInt(NodePropStr[CurrArrayIndex][AXIS_Z])), TID);
				break;

				case NODE_PRECISE:
				SpawnForced("TDBots_PrecisionNode",
				fixed(StrToInt(NodePropStr[CurrArrayIndex][AXIS_X])),
				fixed(StrToInt(NodePropStr[CurrArrayIndex][AXIS_Y])),
				fixed(StrToInt(NodePropStr[CurrArrayIndex][AXIS_Z])), TID);
				break;

				default:
				log(s:"Unknown node type ", s:NodePropStr[CurrArrayIndex][NODE_TYPE]);
			}

			NodeTID[CurrArrayIndex] = TID;

			CurrArrayIndex++;
			delay(1);
		}
		else
		{
			break;
		}
	}

	if(currarrayindex != 0)
	{
		Log(i: currarrayindex, s:" Nodes fully loaded.");
		Log(s:"Nodelist version: ",i: NodelistVersion);
	}
	else if(GetCVAR("tdbots_learnfromplayer"))
	{
		while(TSMS <= (35*120))
		{
			delay(1);
			TSMS++;
			if( (TSMS == (35*30) ) || (TSMS == (35*60) ) || (TSMS == 30*90) )
				TDB_CopyNodeTIDs();
		}
		TDB_CopyNodeTIDs();
	}
}
/*
Script "TDBots_DumpLoadedNodes"
{
	if(NodeTID[0] == 0) {terminate;}

	str NodeDump = "";
	int currtid;
	for(int i; i < MAX_NODES; i++)
	{
		currtid = PlayNodeTID[i];
		if(currtid == 0) {break;}

		NodeDump = StrParam(s:NodeDump, i:PlayNodePos[i][0], s:";", i:PlayNodePos[i][1], s:";", i:PlayNodePos[i][2], s:";", i:PlayNodePos[i][3], s:";");
		if( (i % 128) == 0) {delay(1);}
	}

	//cuts the last ; off from the string
	if(GetChar(NodeDump, StrLen(NodeDump)-1) == ';')
	{
		NodeDump = StrLeft(NodeDump, StrLen(NodeDump)-1);
	}

	Log(s:StrParam(n:PRINTNAME_LEVEL, s:"NodesNew = \"", s:NodeDump, s:"\";"));
}
*/
