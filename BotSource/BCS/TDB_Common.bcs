#ifdef DEBUG_MODE
	#define PRINT_STATENAME if(justEntered) \
		logf("%n: %s", 0, __FUNCTION__)
#else
	#define PRINT_STATENAME ;
#endif

raw abs (raw x)
{
	if(x < 0)
		return -x;
	return x;
}

void TDB_NewTempTID()
{
	r1 = UniqueTID();
	r2 = ActivatorTID();
	Thing_ChangeTID(0, r1);
	return;
}

void TDB_BotLook (int fov)
{
	int oldAccuracy = GetActorProperty(0, APROP_Accuracy);
	SetActorProperty(0, APROP_Accuracy, fov);
	DecoAction("TDBot_Look");
	SetActorProperty(0, APROP_Accuracy, oldAccuracy);
}

void TDB_SetActorFlag (int tid, str flag, bool e)
{
	int oldAccuracy = GetActorProperty(tid, APROP_Accuracy);
	SetActorProperty(tid, APROP_Accuracy, e);
	if(tid)
		GiveActorInventory(tid, StrParam(s:"TDB_CAF_", s:flag), 1);
	else
		GiveInventory(StrParam(s:"TDB_CAF_", s:flag), 1);
	SetActorProperty(tid, APROP_Accuracy, oldAccuracy);
}

Script "TDBot_TargetIsNode"
{
	if(!SetActivator(0, AAPTR_TARGET))
		return false;

	return CheckInventory("TDBots_IDoExist");
}

Script "TDBot_CheckPointer" (int ptr)
{
	return SetActivator(0, ptr);
}

Script "TDBot_IsTargetAlive"
{
	if( (!SetActivator(0, AAPTR_TARGET)) || CheckInventory("TDBots_IDoExist") )
		return false;
	
	return (GetActorProperty(0, APROP_HEALTH) > 0) && !PlayerIsSpectator(PlayerNumber());
}

Script "TDBot_TargetIsShootable"
{
	if(!SetActivator(0, AAPTR_TARGET))
		return false;

	SetResultValue((int)CheckFlag(0, "SHOOTABLE"));
}

Script "TDBot_GetDistToTarget"
{
	fixed x = GetActorX(0);
	fixed y = GetActorY(0);
	
	SetActivator(0, AAPTR_TARGET);
	
	return VectorLength(GetActorX(0) - x, GetActorY(0) - y);
}

Script "TDBot_CheckSightToTarget"
{
	int oldTID = ActivatorTID();
	int tid = UniqueTID();
	Thing_ChangeTID(oldTID, tid);

	if(SetActivator(0, AAPTR_TARGET))
		SetResultValue((raw)CheckSight(tid, 0, CSF_NOFAKEFLOORS));

	SetActivator(tid);
	Thing_ChangeTID(0, oldTID);
}

bool LOFResult;
Script "TDBot_SetLOFResult"
{
	LOFResult = TRUE;
	delay(1);
	LOFResult = FALSE;
}

fixed fmod(fixed a, fixed b)
{
	if (a < 0.0)
	{
		fixed rem = a % (raw)b;
		if (rem != 0.0)
			return b + (a % (raw)b);
		return 0.0;
	}

	return a % (raw)b;
}

fixed TDB_GetSpeed ()
{
	fixed spd = fixed((int)GetActorProperty(0, APROP_ACCURACY));
	
	if(spd == 0.0)
		return 17.0;
	return spd;
}

bool TDB_ActorExists (str actor)
{
	int TID = UniqueTID();
	if(!SpawnForced(actor, 0.0, 0.0, 0.0, TID))
		return FALSE;
		
	Thing_Remove(TID);
	return TRUE;
}

function bool KeyPressed(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

int TDB_CheckWall (fixed dist = 8.0, bool checkJump = TRUE)
{
	fixed angle = GetActorAngle(0);
	
	dist += GetActorProperty(0, APROP_RADIUS);
	
	fixed x = GetActorX(0) + (dist * cos(angle));
	fixed y = GetActorY(0) + (dist * sin(angle));
	fixed z = GetActorZ(0) + GetActorViewHeight(0);
	
	int TID = UniqueTID();
	
	bool result = !Spawn("TDBot_WallChecker", x, y, z, TID);
	
	Thing_Remove(TID);
	
	int pNum = PlayerNumber();
	
	if( checkJump && ((GetActorVelZ(0)+self.oldVelZ == 0.0) && (GetCVAR("sv_jump") != 2) && result) )
	{	
		if(Spawn("TDBot_WallChecker", x, y, z + GetActorProperty(0, APROP_JUMPZ), TID))
		{
			TDB_PressKey(BT_JUMP);
			Thing_Remove(TID);
			return 2; //jumped
		}
	}
	
	/*#ifdef DEBUG_MODE
		Print(i:result);
	#endif*/
		
	return (int)result;
}

//TRUE if specified class has been replaced, FALSE if not
bool CheckReplacement (str class)
{
	int TID = UniqueTID();
	if(!SpawnForced(class, 0.0, 0.0, 0.0, TID))
		return FALSE;
		
	bool retval = StriCmp(GetActorClass(TID), class) != 0;
	
	Thing_Remove(TID);
	
	return retval;
}

internal void TDB_UpdateWeaponFlags ()
{
	int TID = UniqueTID();
			
	SpawnForced(self.weaponName, 0.0, 0.0, 0.0, TID);

	self.weaponFlags = 0;
	
	//Oftentimes checking this flag results in an erroneous TRUE on the starting
	//weapon, even if it isn't a melee weapon at all (of course, this fix can
	//cause the opposite problem, but really that's much less common, and
	//can be fixed by adding exceptions).
	if(CheckFlag(TID, "MELEEWEAPON") && (self.weaponName != self.firstWeapon) )
	{
		#ifdef DEBUG_MODE
			logf("Weapon %s is a melee weapon", self.weaponName);
		#endif
		self.weaponFlags |= TDB_CW_MELEE;
	}
	else
			
	if( (CheckFlag(TID, "EXPLOSIVE")) || (self.weaponName == "RocketLauncher") )
	{
		#ifdef DEBUG_MODE
			logf("Weapon %s is an explosive weapon", self.weaponName);
		#endif
		self.weaponFlags |= TDB_CW_EXPLOSIVE;
	}
	
	Thing_Remove(TID);
}

// By DarkAssassin.
Script "TDB_FaceTarget" (int noPitch, int theirID)
{
	int myOldID, myID;

	if(!theirID)
	{
		// Create a temporary unique TID, as the bot's TID may be 0 or shared with other things.
		myOldID = ActivatorTID();
		myID = UniqueTID();
		Thing_ChangeTID(0, myID);

		if(!SetActivator(myID, AAPTR_TARGET))
		{
			Thing_ChangeTID(myID, myOldID);
			terminate;
		}
	}

	// Set angle and pitch.
	fixed x = GetActorX(theirID) - GetActorX(myID);
	fixed y = GetActorY(theirID) - GetActorY(myID);
	if(!noPitch)
	{
		fixed z = (((fixed)GetActorProperty(theirID, APROP_Height) * 0.5) + GetActorZ(theirID)) - (GetActorZ(myID) + GetActorViewHeight(myID));
		SetActorPitch(myID, -VectorAngle(VectorLength(x, y), z));
	}
		
	SetActorAngle(myID, VectorAngle(x, y));

	if(!theirID)
		Thing_ChangeTID(myID, myOldID);
}

//from ACSUtils
raw RandomPick2(raw v0, raw v1)
{
	if (Random(0, 1))
		return v0;
	return v1;
}

raw RandomPick3(raw v0, raw v1, raw v2)
{
	int x = Random(0, 2);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	}

	return v2;
}

raw RandomPick4(raw v0, raw v1, raw v2, raw v3)
{
	int x = Random(0, 3);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	}

	return v3;
}

raw RandomPick5(raw v0, raw v1, raw v2, raw v3, raw v4)
{
	int x = Random(0, 4);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	}

	return v4;
}

raw RandomPick6(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5)
{
	int x = Random(0, 5);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	}

	return v5;
}

raw RandomPick7(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5, raw v6)
{
	int x = Random(0, 6);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	case 5: return v5;
	}

	return v6;
}

raw RandomPick8(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5, raw v6, raw v7)
{
	int x = Random(0, 7);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	case 5: return v5;
	case 6: return v6;
	}

	return v7;
}

raw RandomPick9(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5, raw v6, raw v7, raw v8)
{
	int x = Random(0, 8);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	case 5: return v5;
	case 6: return v6;
	case 7: return v7;
	}

	return v8;
}

bool TDB_FollowPlayer ()
{
	if(CheckInventory("BotAttack"))
		return false;

	TakeInventory("TDBots_TempNode", 1);
	
	fixed dist, newdist, angToPlayer;
	int node;

	int pNum;

	int botnum = PlayerNumber();
	fixed teledist = bcs::FIXED_MAX;
	
	if(teledist > 0.0)
	{
		if(teledist < 1024.0)
			teledist = 1024.0;

		dist = 16384.0;
	}
	else
	{
		dist = 2048.0;
	}
	
	self.goalNode = 0;

	if(IsNetworkGame()) //if not network game then pnum will always be 0
	{
		for(int i_ = 0; i_ < MAX_PLAYERS; i_++)
		{	
			if((PlayerLocation[i_][0] + PlayerLocation[i_][1]) != 0.0)
			{
				newdist = VectorLength(PlayerLocation[i_][0] - GetActorX(0),
									   PlayerLocation[i_][1] - GetActorY(0));
				
				angToPlayer = VectorAngle(PlayerLocation[i_][0] - GetActorX(0),
										  PlayerLocation[i_][1] - GetActorY(0));
				
				if( (newdist < dist) && (!PlayerIsSpectator(i_)) && (!PlayerIsBot(i_)) )
				{
					dist = newdist;
					pnum = i_;
				}
			}
		}
		
		if(PlayerIsSpectator(pnum) || PlayerIsBot(pnum) || (botnum == pnum) ) {return FALSE;}
	}
	else
	{
		if((raw)PlayerIsSpectator(0) != 0) {return FALSE;}
		dist = VectorLength(PlayerLocation[0][0] - GetActorX(0),
							PlayerLocation[0][1] - GetActorY(0));
		
		angToPlayer = VectorAngle(PlayerLocation[0][0] - GetActorX(0),
								  PlayerLocation[0][1] - GetActorY(0));
	}
	
	if(dist < 128.0)
	{
		TDB_SetMove(0.0, 0.0);
		return true;
	}
	
	dist = 768.0;
	for(int i = 0; i < MAX_FOLLOW_NODES; i++)
	{
		node = PlayerFollowTID[pnum][i];
		if(node == 0) {break;}

		if(ThingCount(T_NONE, node) > 0)
		{
			newdist = Distance(0, node);
			
			if( (newdist < dist) && CheckSight(0, node, CSF_NOFAKEFLOORS) )
			{
				dist = newdist;
				self.goalNode = node;
			}
		}
	}
	
	DLogf("following player, node %i", self.goalNode);
	return bool(self.goalNode);
}

bool TDB_OnGround ()
{
#ifdef QZANDRONUM
	return CheckSolidFooting(0, 0) != CSF_INAIR;
#else
	fixed velz = GetActorVelZ(0);

	if( (velz < -8.0) || (velz > 0.0) ) {return FALSE;}

	fixed rad = GetActorProperty(0, APROP_Radius);

	fixed x1,y1,z1;
	fixed x2,y2,z2;
	fixed dist;

	int tid1 = UniqueTID();
	int tid2 = UniqueTID();

	SpawnForced("BA_CheckGround", 0.0, 0.0, 0.0, tid1);
	SpawnForced("BA_CheckGround", 0.0, 0.0, 0.0, tid2);

	for(fixed ix = -rad; ix <= rad; ix += rad)
	{
		for(fixed iy = -rad; iy <= rad; iy += rad)
		{
			Warp(tid1, ix, iy, 0.0, 0.0, WARPF_TOFLOOR|WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEOFFSET|WARPF_MOVEPTR);
			Warp(tid2, ix, iy, 0.0, 0.0, WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEOFFSET|WARPF_MOVEPTR);

			x1 = GetActorX(tid1);
			y1 = GetActorY(tid1);
			z1 = GetActorZ(tid1);

			x2 = GetActorX(tid2);
			y2 = GetActorY(tid2);
			z2 = GetActorZ(tid2);

			dist = z2 - z1;
			if( (dist >= 0.0) && (dist <= 4.0) )
			{
				Thing_Remove(tid1);
				Thing_Remove(tid2);
				return true;
			}
		}
	}

	Thing_Remove(tid1);
	Thing_Remove(tid2);
	return false;
#endif
}

str StrToLower (str in)
{
	int inLen = StrLen(in);
	char c;
	str out;

	buildmsg(out = StrParam())
	{
		for(int i = 0; i < inLen; i++)
		{
			c = in[i];
			if( (c >= 'A') && (c <= 'Z') )
				Append(c:c - 32);
			else
				Append(c:c);
		}
	}

	return out;
}

fixed VectorLength3D (fixed x, fixed y, fixed z)
{
	return VectorLength(VectorLength(x, y), z);
}

enum
{
	WIDTH = 160,
	HEIGHT = 120
};

void HudDrawLine (int x0, int y0, int x1, int y1)
{
    int dx = abs(x1 - x0);
    int sx = x0 < x1 ? 1 : -1;
    int dy = -abs(y1 - y0);
    int sy = y0 < y1 ? 1 : -1;
    int error = dx + dy;

    int i;

    while(true)
    {
		//if(!((++i) % 2))
			//HudMessage(s:"A"; HUDMSG_PLAIN|HUDMSG_LAYER_UNDERHUD|HUDMSG_ALPHA, 0, CR_UNTRANSLATED, fixed(x0) + 0.1, fixed(y0) + 0.1, 0.03, 0.5);
		if( ((x0 > 0) && (x0 < WIDTH)) && ((y0 > 0) && (y0 < HEIGHT)) )
			nodeLinkBuf[y0 * WIDTH + x0] = 'A';
		else
			return;


        int e2 = 2 * error;
        if(e2 >= dy)
        {
            if(x0 == x1)
				break;
            error = error + dy;
            x0 = x0 + sx;
        }
        if(e2 <= dx)
        {
            if(y0 == y1)
				break;
            error = error + dx;
            y0 = y0 + sy;
        }
    }
}

char nodeLinkBuf[WIDTH*HEIGHT];

bool TWorldToViewCoord(int tid, int hudX, int hudY)
{
	// Translated point coordinates.
	fixed x = GetActorX(tid) - GetActorX(0);
	fixed y = GetActorY(tid) - GetActorY(0);
	fixed z = GetActorZ(tid) - (GetActorZ(0) + GetActorViewHeight(0));
	fixed camAng = GetActorAngle(0), camPit = GetActorPitch(0);

	fixed rx, ry, rz;
	fixed s, c;

	// Rotate around Z axis.
	s = sin(-camAng);
	c = cos(-camAng);
	rx = FixedMul(x, c) - FixedMul(y, s);
	ry = FixedMul(x, s) + FixedMul(y, c);
	x = rx; y = ry;

	// Rotate around Y axis.
	s = sin(camPit);
	c = cos(camPit);
	rx = FixedMul(x, c) - FixedMul(z, s);
	rz = FixedMul(x, s) + FixedMul(z, c);
	x = rx; z = rz;

	// Check if point is behind the camera.
	if (x <= 0.0)
		return false;

	// I don't know what this factor means, but it fixes positioning bugs.
	fixed yFactor = 1.6;

	// Half heights.
	fixed hw = fixed(hudX / 2);
	fixed hh = fixed(hudY / 2);

	// Project point.
	fixed drawX = -FixedDiv(y, x);
	fixed drawY = -FixedDiv(z, x);

	// Postprocess projected point.
	drawX += /*$R3D_2DOffsetX +*/ hw + FixedMul(hw, drawX);
	drawY += /*$R3D_2DOffsetY +*/ hh + FixedMul(FixedMul(hh, yFactor), drawY);

	r1 = int(drawX);
	r2 = int(drawY);

	return true;
}

/*bool TWorldToViewCoord(int tid, int hudX, int hudY)
{
	fixed dist, pitch, startPitch = GetActorPitch(0);

	fixed x = GetActorX(tid) - GetActorX(0);
	fixed y = GetActorY(tid) - GetActorY(0);

	fixed vang = VectorAngle(x,y);
	fixed angle = (raw)(vang - GetActorAngle(0) + 1.0) % 1.0;

	if(((raw)(vang+0.125)%0.5) > 0.25) dist = FixedDiv(y, sin(vang));
	else dist = FixedDiv(x, cos(vang));

	if(angle < 0.23 || angle > 0.85)
	{
		if(startPitch >= -0.5 && startPitch <= 0.5)
		{
			pitch = VectorAngle(dist, GetActorZ(tid) - (GetActorZ(0) + GetActorViewHeight(0)));
			pitch += (raw)FixedMul(startPitch, 1.2) % 1.0;

			if(fixed(hudX/2) * Sin(angle) != 0.0 && Cos(angle) != 0.0 && fixed(hudX/2) * sin(pitch) != 0.0 && cos(pitch) != 0.0)
			{
				r1 = int(fixed(hudX/2) - (fixed(hudX/2) * sin(angle) / cos(angle)));
				r2 = int(fixed(hudY/2) - (fixed(hudX/2) * sin(pitch) / cos(pitch)));

				//x += xOffset;
				//y += yOffset;

				return true;
			}
		}
	}

	return false;
}*/

Script "TDB_DrawNodeLinks" ENTER
{
	Delay(16);

	SetHudClipRect(0, 0, 0, 0, WIDTH);
	SetFont("TDB_PIX_FONT");

	int ntid, lntid;
	int x0, y0, x1, y1;
	while(true)
	{
		for(int i = 0; i < lengthof(nodeLinkBuf); i++)
			nodeLinkBuf[i] = 'B';

		foreach(auto n; TDB_Nodes)
		{
			int ntid = n.tid;
			if(!ntid)
				break;

			if(!CheckSight(0, ntid, CSF_NOFAKEFLOORS))
				continue;

			foreach(auto ln; n.links)
			{
				int lntid = ln.node.tid;
				if(!lntid)
					break;

				if(!CheckSight(0, lntid, CSF_NOFAKEFLOORS))
					continue;

				if(!TWorldToViewCoord(ntid, WIDTH, HEIGHT))
					continue;
				x0 = r1;
				y0 = r2;

				if(!TWorldToViewCoord(lntid, WIDTH, HEIGHT))
					continue;
				x1 = r1;
				y1 = r2;

				//if( (x0 < 0) || (x0 > WIDTH) || (y0 < 0) || (y0 > HEIGHT) || (x1 < 0) || (x1 > WIDTH) || (y1 < 0) || (y1 > HEIGHT) )
					//continue;

				HudDrawLine(x0, y0, x1, y1);
			}
		}

		SetHudSize(WIDTH, 1, false);
		HudMessage(s:"A"; HUDMSG_PLAIN|HUDMSG_LAYER_UNDERHUD|HUDMSG_ALPHA, 0, CR_UNTRANSLATED, 0.1, 0.0, 0.03, 0.5);
		HudMessage(s:"A"; HUDMSG_PLAIN|HUDMSG_LAYER_UNDERHUD|HUDMSG_ALPHA, 0, CR_UNTRANSLATED, fixed(WIDTH) + 0.1, 0.0, 0.03, 0.5);

		SetHudSize(WIDTH, HEIGHT, false);
		HudMessage(a:nodeLinkBuf; HUDMSG_PLAIN|HUDMSG_LAYER_UNDERHUD|HUDMSG_ALPHA, 0, CR_UNTRANSLATED, 0.1, 0.1, 0.03, 0.5);

		Delay(1);
	}
}

Script "TDB_DumpHeap"
{
	bcs::allocDump();
}
